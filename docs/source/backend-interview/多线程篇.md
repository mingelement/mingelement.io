# 这些年背过的面试题——多线程篇

## 线程调度

### 1. 线程状态
线程具有五种状态：创建、就绪、运行、阻塞、死亡。

### 2. 线程状态切换
线程状态之间可以发生转换，如就绪到运行，运行到阻塞等。

### 3. 阻塞唤醒过程
- **阻塞**：线程调用wait()方法后，会释放对象锁并进入等待队列。
- **唤醒**：线程从等待队列中移除，重新成为可调度线程。

### 4. wait和sleep区别
- **wait**：必须在synchronized代码中使用，会释放monitor锁。
- **sleep**：可以在任何地方使用，不会释放monitor锁。

### 5. 创建线程方式
- 实现Runnable接口
- 实现Callable接口
- 继承Thread类
- 使用线程池

## 线程池

### 1. 线程池构造函数
`ThreadPoolExecutor`类有七个参数，包括核心线程数、最大线程数等。

### 2. 线程处理任务过程
线程池处理任务的过程包括创建线程、执行任务、释放线程等步骤。

### 3. 线程拒绝策略
当线程池和工作队列都满了，需要拒绝策略来处理新任务。

### 4. Executors类实现线程池
JDK提供了几种线程池的实现，如`newFixedThreadPool()`和`newCachedThreadPool()`。

### 5. 线程池大小设置
根据CPU密集型和IO密集型来设置线程池的大小。

## 线程安全

### 1. 乐观锁，CAS思想
乐观锁适用于读多写少的场景，CAS是乐观锁的一种实现方式。

### 2. synchronized底层实现
synchronized通过对象头的Mark Word实现锁机制。

### 3. ReenTrantLock底层实现
ReentrantLock是API层面的互斥锁，基于CAS操作实现。

### 4. 公平锁和非公平锁区别
公平锁遵循FIFO原则，非公平锁则不保证。

### 5. 使用层面锁优化
包括减少锁的时间、减少锁的粒度、锁粗化等策略。

### 6. 系统层面锁优化
包括自适应自旋锁、锁消除、锁升级等。

### 7. ThreadLocal原理
ThreadLocal为每个线程提供独立的变量副本。

### 8. HashMap线程安全
HashMap在多线程下可能发生死循环，应使用线程安全的ConcurrentHashMap。

### 9. String不可变原因
String的不可变性使得它适合作为HashMap的key，保证了线程安全。

## 内存模型

### 1. volatile底层实现
volatile保证变量的可见性和禁止指令重排。

### 2. AQS思想
AQS是构建锁和同步器的框架，如ReentrantLock和CountDownLatch。

### 3. happens-before
描述操作之间的内存可见性关系。