# 这些年背过的面试题——JVM篇

## JVM内存划分

### 1. JVM运行时数据区域
- **堆（Heap）**：存放对象实例和数组，线程共享。
- **方法区（元空间）**：存放类信息、常量、静态变量。
- **虚拟机栈**：线程私有，存放栈帧。
- **本地方法栈**：服务Native方法。
- **程序计数器**：线程私有，存放下一条指令位置。

### 2. 堆内存分配策略
- 对象优先在Eden区分配。
- 大对象直接进入老年代。
- 长期存活的对象进入老年代。
- 动态对象年龄判定。
- 空间分配担保。

### 3. 创建一个对象的步骤
- 类加载检查。
- 分配内存。
- 初始化零值。
- 设置对象头。
- 执行init方法。

### 4. 对象引用
- **强引用**：普通对象引用。
- **软引用**：内存不足时回收。
- **弱引用**：GC时回收。
- **虚引用**：跟踪垃圾回收活动。

## JVM类加载过程

### 1. 双亲委派机制
每个类都有对应的类加载器，类加载时使用双亲委派模型。

### 2. tomcat的类加载机制
打破双亲委派机制，直接使用ExtClassLoader加载类。

## JVM垃圾回收

### 1. 存活算法和两次标记过程
使用可达性分析法和两次标记过程进行垃圾回收。

### 2. 垃圾回收算法
- 复制算法：用于新生代。
- 标记清除：用于老年代，但会产生碎片。
- 标记整理：解决碎片问题。
- 分代收集：结合不同年代特点选择合适算法。

### 3. 垃圾收集器
- Serial：单线程收集器。
- Parnew：Serial的多线程版本。
- Parallel Scavenge：关注吞吐量。
- Serial Old：Parallel Scavenge的老年代版本。
- CMS：关注最短垃圾回收停顿时间。
- G1：精准控制停顿时间，避免垃圾碎片。
- ZGC：在不关注容量的情况获取最小停顿时间。

### 4. 配置垃圾收集器
根据内存大小、垃圾回收器特点进行配置。

### 5. JVM性能调优
使用jps、jinfo、jstat、jstack、jmap等命令进行问题定位和优化。

## JDK新特性

- JDK8：支持Lambda表达式、集合的stream操作。
- JDK9：默认G1垃圾回收器。
- JDK10：改善G1最坏情况的等待时间。
- JDK11：ZGC，支持4TB堆内存。
- JDK12：Shenandoah GC，停顿时间和堆大小无关。
- JDK13：增加ZGC以将未使用的堆内存返回给操作系统。
- JDK14：删除cms垃圾回收器，弃用ParallelScavenge+SerialOldGC。

## 线上故障排查

### 1. 硬件故障排查
保留现场，使用ss、netstat、sar等命令进行问题排查。

### 2. 报表异常 | JVM调优
通过升级硬件和JVM参数调优解决报表系统OOM问题。

### 3. 大屏异常 | JUC调优
通过线程池限流和熔断处理解决接口延迟问题。

### 4. 接口延迟 | SWAP调优
关闭SWAP分区解决服务卡顿问题。

### 5. 内存溢出 | Cache调优
通过代码优化和使用Guava Cache解决内存泄漏问题。

### 6. CPU飙高 | 死循环
使用top和jstack命令排查CPU飙高问题。