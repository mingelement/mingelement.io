# Kubernetes调度器的调度流程和算法介绍

*生成时间*: 2024-10-14 15:34:00  
*生成者*: mingelement

## 章节概述
本章节由阿里云工程师木苏讲解，详细介绍了Kubernetes调度器的架构、调度算法实现、配置方法以及扩展机制。内容涵盖了调度器的工作原理、核心组件、调度流程、优先级与过滤器策略等。

## 关键内容

### 调度器架构
- **FlagSet**: 配置标志集合。
- **Predicates & Priorities & Extenders**: 过滤器、优先级函数和扩展器。
- **File & ConfigMap**: 配置文件和ConfigMap。
- **Policy**: 调度策略。
- **Plugins**: 插件系统。
- **Pod & Node**: Pod和Node对象。
- **PV, PVC, StorageClass, CSINode, PDB**: 持久卷、持久卷声明、存储类、CSI节点和Pod中断预算。
- **Informer**: 用于监听API Server的变化并更新缓存。
- **Schedule Cache**: 调度缓存。
- **Pod调度生命周期管理**: 包括初始化、假设、添加、删除等操作。

### 调度算法实现
#### 调度流程
- **activeQ**: 活跃队列。
- **backoffQ**: 回退队列。
- **unschedulableQ**: 不可调度队列。
- **Filter**: 过滤阶段。
- **Score**: 评分阶段。
- **SelectHost**: 选择主机阶段。
- **Bind**: 绑定阶段。

#### Predicates
- **存储相关**:
  - `NoVolumeZoneConflict`: 校验PVC上的可用zone是否与Node的zone匹配。
  - `MaxCSIVolumeCountPred`: 校验PVC上指定的Provision在CSI plugin上报的单机最大挂盘数。
  - `CheckVolumeBindingPred`: PVC和PV的binding逻辑校验。
  - `NoDiskConflict`: SCSI存储不被重复volume。
- **Pod和Node匹配相关**:
  - `CheckNodeCondition`, `CheckNodeUnschedulable`, `PodToleratesNodeTaints`, `PodFitsHost`, `MatchNodeSelector`。
- **Pod和Pod匹配相关**:
  - `MatchInterPodAffinity`: PodAffinity和PodAntiAffinity的校验逻辑。
- **Pod打散相关**:
  - `EvenPodsSpread`, `CheckServiceAffinity`。

#### Priorities
- **解决的问题**:
  - 碎片、容灾、水位、亲和、反亲和。
- **资源水位**:
  - `LeastRequestedPriority`: 优先打散。
  - `MostRequestedPriority`: 优先堆叠。
  - `BalancedResourceAllocation`: 碎片率。
  - `RequestedToCapacityRatioPriority`: 指定比率的分数。
- **Pod打散**:
  - `SelectorSpreadPriority`, `ServiceSpreadingPriority`, `EvenPodsSpreadPriority`。
- **Node亲和&反亲和**:
  - `NodeAffinityPriority`, `ServiceAntiAffinity`, `NodeLabelPrioritizer`, `ImageLocalityPriority`。
- **Pod亲和&反亲和**:
  - `InterPodAffinityPriority`, `NodePreferAvoidPodsPriority`。

### 如何配置调度器
- **启动调度器**:
  - 默认配置(`--write-config-to`)。
  - 配置文件(`--config`)。
- **配置文件解释**:
  - `schedulerName`: 负责Pod.SchedulerName的调度。
  - `algorithmSource`: 配置算法。
  - `hardPodAffinitySymmetricWeight`: 配置Affinity权重。
  - `percentageOfNodesToScore`: filter到的节点数跟总节点的比率达到这个值时退出filter。
  - `bindTimeoutSeconds`: binding阶段的超时时间。
- **algorithmSource**:
  - `provider`, `file`, `configMap`。

### Scheduler Extender
- **功能**:
  - 不改变原有调度代码，通过插件形式提供扩展功能（类似webhook）。
  - 支持predicate, preempt, priority, bind的注入。
  - 一种ExtendResource, Bind只能一个extender。
- **配置**:
  - 配置文件解释。
- **案例**:
  - 申请GPU显存，但具体的卡有多少显存只有Extender知道，所以增加Extender的Filter。

### Scheduler Framework
- **扩展点用途**:
  - `QueueSort`, `PreFilter`, `Filter`, `PostFilter`, `Score`, `Reserve`, `Permit`, `PreBind`, `Wait Thread Bind`, `PostBind`, `Unreserve`。
- **并发模型**:
  - 支持自定义Pod的排序。
  - 对Pod请求做预处理。
  - 自定义filter逻辑。
  - 数据预处理。
  - 自定义Score逻辑。
  - 有状态的plugin可以对资源做内存记账。
  - wait, deny, approve, 可以作为gang的插入点。
  - 在真正绑定Node之前执行一些操作，例如云盘挂载。
  - 一个Pod只会被一个BindPlugin处理。
  - 绑定成功之后执行的逻辑。
  - 在permit到Bind这几个阶段只要报错就回退。
- **编写注册自定义Plugin**:
  - `vendor`, `fork`。

## 主要观点
- Kubernetes调度器通过一系列的过滤器和优先级函数来决定将Pod分配到哪个节点。
- 调度器架构包括多个组件和阶段，确保高效且可靠的调度过程。
- 通过配置和扩展机制，调度器可以适应不同的需求和场景。

## 结论与启示
- 了解Kubernetes调度器的架构和工作原理对于优化集群性能和资源利用率至关重要。
- 通过合理配置和使用扩展机制，可以提高调度器的灵活性和适应性。
- 调度器的优化是一个持续的过程，需要根据实际需求进行调整和改进。

## 思考问题
1. Kubernetes调度器如何决定将Pod分配到哪个节点？
2. 如何配置和优化Kubernetes调度器？
3. 什么是Scheduler Extender，它有哪些应用场景？
4. Scheduler Framework提供了哪些扩展点，它们的作用是什么？

## 重要引用
> "kube-scheduler通过一定的策略来缩小Node的取样规模，举例：配置配置比率10%，集群节点数allNodes=3000，那么numNodesToFind= Max(3000* 10/100, 100)，100是默认最小需要值。"

## 关键术语
- **kube-scheduler**: Kubernetes调度器。
- **Predicates**: 过滤器，用于筛选出符合要求的节点。
- **Priorities**: 优先级函数，用于给符合条件的节点打分。
- **Extenders**: 扩展器，允许外部服务参与调度决策。
- **TopologySpreadConstraints**: 拓扑分布约束，用于控制Pod在不同拓扑域中的分布。
- **ServiceAntiAffinity**: 服务反亲和性，避免Pod集中在一个节点上。
- **ImageLocalityPriority**: 镜像亲和调度，优先选择已有镜像的节点。
- **InterPodAffinityPriority**: Pod亲和性和反亲和性的校验逻辑。
- **NodePreferAvoidPodsPriority**: 针对RC和RS在宿主机上打表对哪些RC/RS反亲和。
- **Scheduler Framework**: 调度器框架，提供多个扩展点以增强调度器的功能。